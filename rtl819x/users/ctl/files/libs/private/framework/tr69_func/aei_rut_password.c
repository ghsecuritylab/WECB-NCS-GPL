/***********************************************************************
 *
 *  Copyright (c) 2012  Actiontec Electronics Inc.
 *  All Rights Reserved
 *
 *  Arithmetic of the root password for TELUS
 *
 ************************************************************************/
#if (defined( AEI_WECB_CUSTOMER_TELUS ) || defined(AEI_WECB_CUSTOMER_NCS)) && defined (AEI_GENERATER_UNIQUELY_PASSWORD)
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "ctl.h"
#include "ctl_util.h"
#include "apmib.h"
#include "aei_rut_password.h"
#ifdef AEI_USERPWD_MD5
#include "aei_md5_encode.h"
#include "ctl.h"
#include "ctl_mem.h"
#include "tsl_strconv.h"
#endif


//const char STATICTABLE[6][16] = {
//    { 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48 },
//    { 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64 },
//    { 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80 },
//    { 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96 },
//    { 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112 },
//    { 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 46, 69 }};

const char STATICTABLE[6][16] = {
    {46, 69, 67, 52, 37, 55, 90, 61, 71, 39, 62, 86, 96, 36, 118, 50},
    {120, 112, 93, 70, 92, 82, 125, 122, 97, 102, 99, 107, 85, 77, 42, 34},
    {103, 49, 123, 100, 113, 57, 59, 76, 106, 114, 44, 80, 108, 81, 65, 121},
    {41, 105, 54, 109, 33, 78, 40, 87, 60, 45, 124, 111, 101, 48, 98, 38},
    {88, 43, 47, 104, 56, 119, 83, 53, 91, 117, 84, 58, 64, 95, 68, 110},
    {72, 79, 89, 35, 126, 51, 73, 115, 74, 75, 64, 107, 63, 116, 83, 66}};




void AEI_rut_getAdminPassword(tsl_char_t *adminPassword,tsl_char_t *serialnum)
{
#if 1
/*
    Here is the Serial Number format for WCB3000.
        B13       ~        B0
        SD 1 13 03 0 00 00 18
        __ _ __ __ __________
        |  | |  |      |
        |  | |  |      +- Index of Week
        |  | |  +- Week of Year
        |  | +- Year
        |  + Unknown
        + Unknown

    There's a string printed on WCB3000 label. It seems to be generated by SN, length of 8 Bytes.
        B13       ~        B0
        SD 1 13 03 0 00 00 18
              _ __    _______
              |  |      |
              |  |      +- Index of Week
              |  +- Week of Year
              +- Year

    Solution:
        use this string as default password of 'admin' account.
        Default password of admin = B10~B8,B5~B0
*/
    if( 14 != tsl_strlen(serialnum) ) {
        // If length of SN was not 14, it must be an unknown format.
        // For this case, just using SN as default password for 'admin', same as V1000H.
        sprintf(adminPassword,"%s",serialnum);
    } else {
        tsl_int_t n=0;
        tsl_char_t tmp_serialnum[9]={0};
        n=tsl_strlen(serialnum);
        memcpy(tmp_serialnum,serialnum+4,3);
        memcpy(tmp_serialnum+3,serialnum+n-5,5);
        //ctllog_error("start get tmp_serialnum=%s",tmp_serialnum);
        tsl_strncpy(adminPassword,tmp_serialnum,9);
    }
#else
    sprintf(adminPassword,"%s",serialnum);
#endif
}

void AEI_rut_getRootPassword(tsl_char_t *rootPassword,tsl_int_t root_len,tsl_char_t *RandomRootPassword,tsl_char_t * serialnum,tsl_int_t ser_len)
{
   tsl_int_t ret = -1;
   unsigned char macAddr[6]={0};
   tsl_char_t macAddress[BUFLEN_64]={0};
   tsl_char_t fixedRootPassword[BUFLEN_64]={0};
   tsl_char_t rootPassword_seed[BUFLEN_256]={0};
   /*get eth0 mac address from apmib*/
    do {
        if ( !apmib_init()) {
            fprintf( stderr, "Initialize AP MIB failed!\n");
            break;
        }
        if ( !apmib_init_HW()) {
            fprintf( stderr, "Initialize AP MIB HW failed!\n");
            break;
        }
        /* Check HW_NIC0_ADDR */
        if( !apmib_get( MIB_HW_NIC0_ADDR, (void *)macAddr)) {
            fprintf( stderr, "APMIB get HW_NIC0_ADDR failed\n" );
            break;
        }
        ret = 1;
    } while(0);
	if(ret==1)
	{
	    sprintf(macAddress, "%02X%02X%02X%02X%02X%02X",
        (unsigned char) macAddr[0], (unsigned char) macAddr[1],
        (unsigned char) macAddr[2], (unsigned char) macAddr[3],
        (unsigned char) macAddr[4], (unsigned char) macAddr[5]);
         ctllog_debug("get :++macAddress is: %s\n",macAddress);
		 if(strlen(serialnum)==0){
         /*coverity CID:33337,33331: Wrong sizeof argument (SIZEOF_MISMATCH)*/
         snprintf(serialnum,ser_len,"%s",macAddress);   
        }
	}
	 ctllog_debug("debug:++Serial number is: %s\n",serialnum);
	if(RandomRootPassword!=NULL) 
	{
	 tsl_strncpy(fixedRootPassword,RandomRootPassword,sizeof(fixedRootPassword));	
	}
	else
	{
	tsl_strncpy(fixedRootPassword,"Thr33scr33n!",sizeof(fixedRootPassword));
	}
	ctllog_debug("debug:++fixedRootPassword is: %s\n",fixedRootPassword);
	 //Randomized  the root password by fixed root password, serial number and mac address.
    snprintf(rootPassword_seed, sizeof(rootPassword_seed), "%s%s%s", fixedRootPassword,serialnum,macAddress);
    ctllog_debug("debug:++rootPassword_seed is: %s\n",rootPassword_seed);
    AEI_getRootPassword(rootPassword_seed,rootPassword,root_len);
    ctllog_debug("debug:++real root password is: %s\n",rootPassword);

}
unsigned int AEI_getPositionCard(char * md5Str)
{
    unsigned int n[4] = {0};    
    tsl_char_t buff[9] = {'\0'};

    int i;
    for(i = 0; i < 4; i ++)
    {
        strncpy(buff, md5Str + i * 8, 8);
        buff[8] = '\0';
        sscanf(buff, "%x", &n[i]);
    }

    unsigned int positionCard = n[0] ^ n[1] ^ n[2] ^ n[3];
    return positionCard;
}

void AEI_getPassword(tsl_char_t * md5Str, tsl_char_t *outPwd)
{

    unsigned int positionCard = AEI_getPositionCard(md5Str);
    printf("--%d\n",positionCard);
    //use right shifting to get 8 chars
    //because Java has no sprintf or sscanf
    int scale[8] = {0};
    int i = 0;
    for(i = 0; i < 8; i ++)
    {
        scale[i] = positionCard & 0x0f;
        positionCard = positionCard >> 4;
    }

    unsigned char pwd[7] = {0};
    pwd[6] = '\0';

    int x = scale[6] % 6;
    int y = scale[7];

    for(i = 0; i < 6; i ++)
    {
        int nx = (x + i) % 6;
        int ny = (y + scale[i]) % 16;
        pwd[i] = STATICTABLE[nx][ny];
    }
    strcpy(outPwd, pwd);

}

void AEI_getRootPassword(tsl_char_t *rootPassword_seed,tsl_char_t * rootPassword,tsl_int_t root_len){
    ctllog_debug("debug:++rootPassword_seed is: %s\n",rootPassword_seed);
    unsigned char md5inbuf[BUFLEN_256]={0};
    unsigned char md5buf[BUFLEN_64]={0};
    tsl_char_t  password[BUFLEN_16]={0};
    /*coverity CID:27849:Copy into fixed size buffer (STRING_OVERFLOW)*/
    snprintf(md5inbuf,sizeof(md5inbuf),"%s",rootPassword_seed);
    AEI_encrypt(md5inbuf,md5buf);
    ctllog_debug("debug:++Md5 encode value is: %s\n",md5buf);
    AEI_getPassword(md5buf,password);
    ctllog_debug("debug:++real password is: %s\n",password);
    snprintf(rootPassword,root_len,"%s",password);
}
#endif
